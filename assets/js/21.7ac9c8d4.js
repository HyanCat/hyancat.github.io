(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{573:function(e,t,s){"use strict";s.r(t);var a=s(11),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("一直想用 swoole，却一直没有真正地去了解它。")]),e._v(" "),s("p",[e._v("前些天看到群里有人讨论相关的技术问题，于是下定决心试一试。但是真正搞定它前后折腾了近一个星期。")]),e._v(" "),s("h3",{attrs:{id:"起步"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#起步"}},[e._v("#")]),e._v(" 起步")]),e._v(" "),s("p",[e._v("试用一下 swoole，很简单，官网的 "),s("a",{attrs:{href:"https://wiki.swoole.com/wiki/page/p-server.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("swoole server 例子"),s("OutboundLink")],1)]),e._v(" "),s("p",[e._v("本地环境 ab 测一下：")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://pico.oss-cn-hangzhou.aliyuncs.com/blog/2mq13.jpg",alt:"ab"}})]),e._v(" "),s("p",[e._v("简直惊叹！当然官方的压测数据更详细和准确： "),s("a",{attrs:{href:"https://wiki.swoole.com/wiki/page/62.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("压力测试"),s("OutboundLink")],1)]),e._v(" "),s("h3",{attrs:{id:"laravel-结合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#laravel-结合"}},[e._v("#")]),e._v(" Laravel 结合")]),e._v(" "),s("p",[e._v("Swoole 虽强，但是还是要能和项目结合好才算能用。")]),e._v(" "),s("p",[e._v("调研了几个 laravel 的 swoole 库之后，选择了 "),s("a",{attrs:{href:"https://github.com/huang-yi/laravel-swoole-http",target:"_blank",rel:"noopener noreferrer"}},[e._v("huang-yi/laravel-swoole-http"),s("OutboundLink")],1),e._v("，他对 swoole 的封装实现比较好。当然他只实现了 http server，目前也是足够了。")]),e._v(" "),s("p",[e._v("如果项目比较简单，基于 Laravel 并且没有太多的修改，那么可能 1 个小时就能立竿见影了。但是项目复杂了就折腾起来没完了。")]),e._v(" "),s("p",[e._v("研究了下实现的源码，原理还比较简单，和 "),s("code",[e._v("artisan serve")]),e._v(" 差不多。")]),e._v(" "),s("ol",[s("li",[e._v("管理 swoole "),s("code",[e._v("start")]),e._v(" "),s("code",[e._v("stop")]),e._v(" 等几个命令；")]),e._v(" "),s("li",[e._v("启动 Laravel Application；")]),e._v(" "),s("li",[e._v("监听 swoole http server 的 request 等几个事件；")]),e._v(" "),s("li",[e._v("将数据传给 Laravel 的 "),s("code",[e._v("request")]),e._v("，并将 Laravel 的 "),s("code",[e._v("response")]),e._v(" 传出来。")])]),e._v(" "),s("h3",{attrs:{id:"docker-结合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-结合"}},[e._v("#")]),e._v(" Docker 结合")]),e._v(" "),s("p",[e._v("自从用了 docker，什么东西都想 docker 化。项目也一直运行在 docker 环境下好几年了。所以必须把 swoole 在 docker 里跑起来。")]),e._v(" "),s("p",[e._v("定制一个 swoole 的 docker 容器倒也简单，"),s("a",{attrs:{href:"https://github.com/ruogoo/docker-env/blob/develop/swoole/Dockerfile",target:"_blank",rel:"noopener noreferrer"}},[e._v("Dockerfile"),s("OutboundLink")],1),e._v("\n把该装的装上。")]),e._v(" "),s("p",[e._v("docker-compose.yml 里多一条 command:")]),e._v(" "),s("div",{staticClass:"language-dockerfile extra-class"},[s("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[s("code",[e._v("  swoole:\n    build: ./swoole\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# ...")]),e._v("\n    command: php /docker/app/someproject/artisan swoole:http start\n")])])]),s("p",[e._v("稍麻烦的是 Nginx 的配置，不再是 fastcgi 的方式，而是反向代理到 swoole 的 http server，简单配置示例如下：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("# laravel swoole config example.\nserver {\n    listen 80;\n    server_name swoole.app;\n\n    access_log  /var/log/nginx/host.access.log  main;\n\n    root  /docker/app/someproject/public;\n    index index.php;\n\n    location / {\n        try_files $uri $uri/ @swoole;\n    }\n\n    # 由于 http server 支持不完善，需要传递 header\n    proxy_set_header   HOST $host;\n    proxy_set_header   SERVER_PORT $server_port;\n    proxy_set_header   REMOTE_ADDR $remote_addr;\n    proxy_set_header   X-Real-IP $remote_addr;\n    proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_http_version 1.1;\n\n    # 这里注意：如果是无路径的 URL，需要加 /\n    location = /index.php {\n        proxy_pass http://swoole:1215/;\n    }\n\n    location @swoole {\n        proxy_pass http://swoole:1215;\n    }\n\n    location ~ /\\.ht {\n        deny    all;\n    }\n}\n")])])]),s("h3",{attrs:{id:"坑"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#坑"}},[e._v("#")]),e._v(" 坑")]),e._v(" "),s("ol",[s("li",[s("p",[e._v("Docker 端口容易混乱")]),e._v(" "),s("p",[e._v("这个坑算自己的失误，要管理的容器太多了，端口映射就乱了。项目里配置的端口，Dockerfile 里开放的端口，docker-compose 里映射的端口，以及 Nginx 里反向代理的端口，都要对应得上（不需要一样），很容易混乱，导致调了很久还是 502。")])]),e._v(" "),s("li",[s("p",[e._v("Nginx 配置")]),e._v(" "),s("p",[e._v("Nginx 的配置需要揣摩每一项的意思，并思考还缺少什么，分析请求到达 Nginx 之后是如何转给 swoole 的。很多次访问静态文件是可以，但访问 php 页面就 502 了。这里调了很久很久。")])]),e._v(" "),s("li",[s("p",[e._v("require_once 大坑货")]),e._v(" "),s("p",[e._v("Nginx 配置好了，不再 502 了，却一直是 404 了。开始找了很久都没找到原因，一直以为是缺少了什么，导致请求没有找到目标。但是后来一想，Laravel 的 Application 也启动了，那 404 肯定就是 Laravel 内部抛出来的。然后就一点点 log 调试（好吧，当时好像不知道为什么不能看错误栈），终于发现是 route 丢了。")]),e._v(" "),s("p",[e._v("什么，丢了？")]),e._v(" "),s("p",[e._v("对，就是本来所有的 route 都加载进去了，但是又丢了。就是在 swoole onRequest 的时候，会 reset 并重新加载一些 ServiceProvider (待考究)。")]),e._v(" "),s("p",[e._v("PHP 对于引入代码文件一般用 "),s("code",[e._v("require_once")]),e._v(" 避免重复 require，比如我的 RouteServiceProvider 中需要 require 路由文件：")]),e._v(" "),s("div",{staticClass:"language-php extra-class"},[s("pre",{pre:!0,attrs:{class:"language-php"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("class")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name-definition class-name"}},[e._v("RouteServiceProvider")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("extends")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("ServiceProvider")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/**\n     * `map()` called by parent's `loadRoutes()`.\n     */")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function-definition function"}},[e._v("map")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("require_once")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("base_path")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token string single-quoted-string"}},[e._v("'route/web.php'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("require_once")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("base_path")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token string single-quoted-string"}},[e._v("'route/passport.php'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("require_once")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("base_path")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token string single-quoted-string"}},[e._v("'route/api_v3.php'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),s("p",[e._v("就在这里，路由文件是 "),s("code",[e._v("require_once")]),e._v(" 的，加载一次后就不再被加载了，swoole 启动后实际的路由被清空了，改成 "),s("code",[e._v("require")]),e._v(" 就好了。。。")])]),e._v(" "),s("li",[s("p",[e._v("上线后才发现的一个大坑：共享单例")]),e._v(" "),s("p",[e._v("之前知道会有这个问题，但一时忽略了，没有重视，上线后才发现并意识到，赶紧回滚。。")]),e._v(" "),s("p",[e._v("Laravel 的容器里有很多单例，比如 Auth、Session、View 等。使用 phpfpm 等 fastcgi 方式的话，任何两个请求互不相干，单例的生命周期只在 response 之后就结束。而使用 swoole 之后，应用程序是先加载到内存中，单例是一直活跃的，前后两个请求用到的单例对象就是同一个。会出现 session 串了的问题。解决办法是 onRequest 的时候 reset 这些单例，重新 new 一个出来。")]),e._v(" "),s("p",[e._v("好吧，我试图改了很多地方，还是有问题。")]),e._v(" "),s("p",[e._v("于是，暂时放弃。慢慢研究。🤪")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);